---
title: '17: User Authentication'
layout: posts
---

Käyttäjien autentikointi on hyvin iso osa ohjelmisto&shy;turvallisuutta. Nykyään yleisimmin käytetty keino autentikointiin on salasanojen käyttö, mutta tässä on useita haittapuolia: ne on usein helppo arvata, niiden takaisinsaamisen tai uusimisen keinot pienentävät turvallisuutta, käyttäjillä on usein sama salasana useaan erilliseen palveluun ja niin edelleen. Myös salasanojen huono säilöminen aiheuttaa riskejä.
 
Yksinkertaisin keino salasanojen säilömiselle on taulukko, jossa kutakin käyttäjää kohti on tallennettu tämän salasana sellaisenaan. Tämä on päivänselvästi huono ratkaisu. Ratkaisua voidaan parantaa hyödyntämällä **salasanojen *hashausta***, jolloin hyökkääjä ei voisi käyttää niitä sellaisenaan. Hyökkääjä voi kuitenkin luoda listan suosituista salasanoista ja niitä vastaavista *hasheista* ja etsiä tätä kautta vastaavuuksia. Tämän tehokkuutta voidaan pienentää hyödyntämällä monimutkaisia *hashaus*-algoritmeja, jolloin salasana&shy;listan alkioiden *hashaamisessa* kuluu huomattavan pitkä aika. Tällainen *hashaus* ei kuitenkaan suojaa tilanteilta, joissa hyökkääjä on onnistunut selvittämään jonkin käyttäjän salasanan, ja voi verrata tämän salasanan *hashia* muihin, mahdollisesti löytäen saman salasanan muiden käyttäjien kohdalta.

*Hashattujen* salasanojen turvallisuutta pyritään parantamaan ns. **“suolaamalla”** ne eli lisäämällä satunnaisuutta *hashien* generointiin. Tämä tapahtuu yleensä käyttämällä käyttäjäkohtaista merkkijonoa suolana. Nyt taulukossa näkyvät *hashatut* salasanat ovat erilaiset, vaikka useammalla käyttäjällä olisikin käytössään sama salasana. 
 
Myös salasanojen lähettäminen asiakkaalta palvelimelle pitää suunnitella turvallisuuden kannalta hyvin, sillä jälleen salasanojen lähettäminen sellaisenaan on huono ratkaisu. Vaihtoehtoisesti voidaan käyttää esimerkiksi salattua yhteyttä, mutta tämäkään ei suojaa ‘*man-in-the-middle*’ -hyökkäyksiltä. Turvallisempi keino onkin käyttää ns. **vaatimus/vaste -protokollaa** (engl. *challenge/response*), jossa asiakas lähettää ensin palvelimelle pyynnön, palvelin vastaa vaatimuksella, ja asiakas sitten hyödyntää tätä vaatimusta *hashatessaan* salasanan serverille lähettämistä varten. Koska vaatimus on palvelimen luoma, se pystyy laskemaan salasanan oikean arvon vastaanotetusta *hashista*. 
 
**‘*Anti-hammering*’** -puolustuksella tarkoitetaan sellaista puolustus&shy;keinoa, jossa salasanojen arvaamisen määrää tai tahtia rajoitetaan. Näihin voi myös liittyä aikakatkaisuja, mikäli salasana on syötetty lyhyessä ajassa väärin riittävän monta kertaa. Nämä vähentävät mm. salasanoja arvaavien skriptien tehokkuutta.
 
Salasanojen huonon turvallisuuden vuoksi tähän luentoon liittyvässä artikkelissa esiteltiin muita mahdollisia keinoja käyttäjien autentikointiin. Voidaan esimerkiksi hyödyntää **biometriikkaa** kuten sormenjälkeä, iiriksen skannausta tai äänen tunnistusta. Näillä on kuitenkin laitteiston aiheuttamien rajoitteiden vuoksi yllättävän pieni entropia (noin sama kuin salasanoilla). Lisäksi niiden käytettävyys on huonompi kuin salasanoilla, sillä esimerkiksi autentikointi&shy;keinon takaisinsaanti tai uusiminen on lähes mahdotona ja kaikki biometriset keinot eivät välttämättä sovellu kaikille ihmisille. Lisäksi nykyiset selaimet tai palvelimet eivät tue näitä. Toisaalta biometrinen autentikointi keskimäärin takaa paremman turvallisuuden kuin salasanat, mutta eivät silti ole täydellisen turvallisia.
 
Toinen ehdotettu keino on ns. **monitekijäinen autentikointi**, jossa yhdistetään erilaisia autentikointi&shy;keinoja. Tällöin on järkevintä yhdistää erityyppisiä keinoja, eli esimerkiksi jotain mitä käyttäjä tietää (kuten salasana) yhdistettynä johonkin, mitä käyttäjä omistaa tai mitä käyttäjä on. Ehdotetuista keinoista kaikkein turvallisin oli ns. ‘*cap reader*’, jossa luotiin jokaista kirjautumista kohti kerran käytettävä salasana luottokortin lukijan avulla. *Cap readerin* käytettävyys on kuitenkin todella heikko, sillä se vaatii erillisen laitteen ja luottokortin mukana kantamista ja jokaista palvelua varten uusien luomista. Yleisesti voidaan sanoa, että paras autentikeino riippuu tilanteesta: mikäli halutaan korkea käytettävyys, salasana on paras keino, mutta jos halutaan korkea turvallisuus, niin kannattaa hyödyntää muita keinoja.
 
 
### Ajatuksia materiaalista
 
Tämän luennon sisältö oli hyvin pitkälti varsin itsestäänselvää, joten minulla ei juurikaan ole aiheesta suuria ajatuksia. Vähän kyllä jäi ihmetyttämään, kun luennoitsija sanoi, että vain joissakin systeemeissä on käytössä ‘*anti-hammering*’ -puolustus, kun mielestäni ei olisi mitään haittaa, että tämä olisi automaattisesti kaikissa. Jos yrityksiä ennen *time-outtia* annetaan vaikka 5-10, niin pitäisi näillä jo päästä sisään, mikäli tietää salasanan. 
 
Liittyen salasanojen korvaamiseen paremmalla autentikointi&shy;menetelmällä tuli mieleen, että ei tuskin olisi helppoa saada järjestelmiä ja näiden käyttäjiä omaksumaan tämä uusi menetelmä, vaikka se olisi kuinka helppo&shy;käyttöinen. Toisaalta on kyllä vaikea keksiä salasanoja helppo&shy;käyttöisempää menetelmää, paitsi ehkä sormenjälki- tai äänitunnistus, mutta ne taas vaativat laitteistolta paljon. Voisi kuitenkin kuvitella, että nykyäänkin monissa palveluissa käytössä oleva kaksois&shy;autentikointi olisi riittävän turvallinen, sillä käyttäjä joutuu mokaamaan useasti, jotta hyökkääjä saisi haltuunsa sekä salasanan, puhelimen että mahdollisesti tähän puhelimeenkin liittyvän salasanan.
 
Loppumainintana vielä, että luennolla mainittu Telepathwords -nettisivu onkin aika hauska. Toivottavasti ei ole rikollisten hallussa, sillä tuli kokeiltua lähes kaikkia käyttämiäni salasanoja…
