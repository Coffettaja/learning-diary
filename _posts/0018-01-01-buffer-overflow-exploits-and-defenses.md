---
title: '3: Buffer Overflow Exploits and Defenses'
layout: posts
---

Edes *baggy bounds* -systeemi ei pysty täydellisesti suojaamaan puskuri&shy;ylivuotoja vastaan. Edellisellä luennolla mainittiin, että edelleen on mahdollista muokata funktio-osoittimien osoitteita. Tämän lisäksi *baggy bounds* ei toimi esimerkiksi silloin, kun koodi on ns. '*uninstrumented code*', jolloin sitä ei voi debugata tai tarkkailla muutenkaan tarkemmin, esimerkiksi profilointiin. Lisäksi *baggy bounds* -systeemissä on muitakin haittapuolia: se saattaa käyttää turhan paljon muistia, tehdä ohjelmasta tehottomamman osoittimien instrumentaation vuoksi (mikä vieläpä vaatii tukea kääntäjältä) ja se saattaa myös tehdä vääriä hälytyksiä. 
 
*Baggy bounds* -systeemin lisäksi on muita huomattavasti suositumpia puolustus&shy;mekanismeja puskuri&shy;ylivuotoja vastaan. Aikaisemmalla luennolla mainittu ‘*stack canaries*’ on todella suosittu. Tämän lisäksi yksi mekanismi on muistin osoitealueiden satunnaistaminen, jolloin esimerkiksi pino saattaa sijaita normaalista poikkeavalla muistialueella. Näin hyökkääjien on vaikea arvata hyökkäyksen kannalta oikeita osoitteita. Hyökkääjä voi silti mahdollisesti keksiä, miten käytetty satunnaistus toimii tai vaihtoehtoisesti hyökkäys saattaa vuotaa joitakin tärkeitä muistiosoitteita hyökkääjälle. Lisäksi tätä lähestymistapaa ei voi käyttää, kun työskennellään todella lähellä laitteistoa, vaikkapa ajurien tapauksessa, koska silloin koodia ei ole mahdollista uudelleensijoittaa haluamallaan tavalla.
 
Toinen puolustusmekanismi on ns. '*non-executable memory*', jonka perusajatuksena on määrittää luku (R), kirjoitus (W) ja suoritus (X) bitit jokaiselle muistin alueelle ja varmistaa, että W ja X bitti eivät voi olla asetettuna samanaikaisesti. Näin pahantekijä ei voi suoraan ohjata ajoa muualla olevaan *shell*-koodiin ja ajaa sitä. Tämän lähestymistavan haittapuolena on, että se estää dynaamisen konetason koodin luonnin, esimerkiksi *just-in-time*-kääntäjien tapauksessa. 
 
'*Non-executable memory*' -puolustuksen voi ohittaa käyttäen ns. '*Return Oriented Programming*' -lähestymistapaa (ROP). ROP:ssa ajatuksena on hyödyntää ns. *gadgetteja* yhdistämään hyökkäyksen kohteena olevasta sovelluksesta löytyviä koodipätkiä hyökkääjän kannalta sopivalla tavalla. Pohjimmiltaan ROP toimii siten, että pinon osoitinta (*stack pointer,* SP) käytetään ikään kuin käskyosoittimena *(instruction pointer,* IP), ja kun SP:tä liikutetaan, osoitetaan muihin koodialueisiin, jotka sitten suoritetaan. Näitä koodialueita yhdistellään yhdistelemällä ***gadgetteja***.
 
*Canary*-puolustuksen puolestaan voi ohittaa keksimällä käytetyn *canaryn* arvon. Tämä on mahdollista erityisesti silloin, kun hyökkäyksen kohteena olevan sovelluksen palvelin kaatuu ja käynnistyy uudelleen, mikäli yksikin *canary*-bitti on väärin. Lisäksi uudelleen&shy;käynnistyessään palvelin ei voi uudelleen&shy;satunnaistaa *canaryn* arvoa tai muita muistiosoitteita. Tämä voi olla tilanne esimerkiksi Linux-palvelimilla, joissa uusi prosessi on *forkattu*, jolloin se saa arvonsa alkuperäiseltä prosessilta, eikä näin uusi arvoja uudelleen&shy;käynnistyessään. Nyt hyökkääjä voi toistuvasti arvata bitti kerrallaan canaryn arvon, ja mikäli arvaus on väärin, palvelin kaatuu ja hyökkääjä saa tästä tiedon.
 
Vaikka useita puolustusmekanismeja yhdistettäisiin, niin puskuri&shy;ylivuoto&shy;hyökkäykset ovat silti mahdollisia. Yksi  keino on 64-bittisiin arkkitehtuureihin hyödynnettävä ns. '***Blind Return Oriented Programming***' (BROP), jossa on useita vaiheita: Ensiksi on löydettävä ns. pysäytys&shy;gadgetti, joka vain pysäyttää ohjelman ajon, ei kaada sitä. Seuraavaksi on löydettävä useita *gadgetteja*, jotka *poppaavat* pinon arvoja. Näiden löytämiseksi käytetään aikaisemmin löydetyn pysäytys&shy;gadgetin lisäksi kahta muuta *gadgettia* (*probe* ja *crash*). Lopullisena tavoitteena on luoda sellaiset *gadgetit*, joiden avulla voidaan *popata* haluttuja arvoja haluttuihin rekistereihin, koska 64-bitin järjestelmissä rekisterit kontrolloivat funktio&shy;kutsujen parametreja. Tämä hyökkäys käyttää hyödykseen palvelimen kaatumista ilman muistialueiden uudelleen&shy;satunnaistamista, joten sitä vastaan on mahdollista puolustautua satunnaistamalla arvot uudelleen.
 
 
### Ajatuksia materiaalista
 
Tällä kolmannella luennolla tuli vastaan todella paljon todella vaikeaa asiaa, joten jo pelkästään luennon aikana tekemäni muistiinpanot venyivät reippaasti yli 500 sanan mittaiseksi, ja jouduinkin tiivistämään asioita todella paljon, ettei tämä päiväkirja&shy;merkintä venyisi järjettömän pitkäksi. Lisäksi katsoin 80 minuutin luentoa yhteensä varmaan 120 minuuttia, kun jouduin katsomaan samat asiat useaan kertaan. Paljon aikaa kului myös tuntemattomien asioiden googlettamiseen. Lopulta kuitenkin uskon saaneeni suhteellisen hyvän käsityksen luennolla esitetyistä puolustuksista ja hyökkäyksistä, vaikken vieläkään aivan kaikkia yksityiskohtia sisäistänyt.
 
Varsinkin luennon loppupuolella ja luentoon liittyvässä artikkelissa esitetty BROP-hyökkäys meni todella monimutkaiseksi, koska siinä yhdistellään niin paljon eri asioita. Kuitenkin omaksi ihmetyksekseni tajusin tämän lopulta varsin hyvin, vaikkakin minulta selkeästi puuttuukin joitakin oleellisia esitietoja esimerkiksi muistin ja pinon toimintaan liittyen. Ei voi kuin ihailla, miten jotkut ovat voineet keksiä näin monimutkaisen hyökkäystavan ja onnistuvat sitä vielä ilmeisesti käyttämäänkin. Jäi kyllä vähän mietityttämään, että miten hyökkäyksen kohteena oleva taho ei huomaisi hyökkäystä, kun se perustuu palvelimen jatkuvaan kaatumiseen. Onko tämä kaatuminen ja uudelleen&shy;käynnistyminen sitten niin nopea toimenpide? Siltikin, tätä luulisi tapahtuvan todella monesti, sillä iso osa hyökkäyksestä perustuu eri bittien arvojen arpomiseen ja vastauksen saamiseen palvelimelta (siis palvelimen kaatumiseen).
 
Loppuhuomautuksena pitää mainita, että on aika mahdotonta keksiä puolillekkaan asiaan liittyville sanoille suomenkielistä vastinetta. Tätä oppimispäiväkirjaa aloittaessani pyrin vielä suomentamaan asioita mahdollisuuksien mukaan, mutta lopulta jo tässä kolmannen luennon kohdalla luovuin tästä ajatuksesta.